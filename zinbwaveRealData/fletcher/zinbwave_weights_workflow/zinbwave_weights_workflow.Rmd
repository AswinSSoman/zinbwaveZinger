---
title: "Fletcher - DE zinbwave weights - clusters from workflow"
author: "Fanny Perraudeau"
date: "`r Sys.Date()`"
output: 
html_document: 
fig_height: 7
fig_width: 7
toc: yes
code_folding: hide
toc_float: yes
---

```{r options, echo=FALSE, results="hide",mesasge=FALSE, error=FALSE, include=FALSE, autodep=TRUE}
knitr::opts_chunk$set(fig.align="center", cache=TRUE, error=FALSE, message=FALSE, warning=TRUE)
library(edgeR)
library(zingeR)
library(RColorBrewer)
library(clusterExperiment)
library(zinbwave)
library(doParallel)
library(BiocParallel)
library(ggplot2)
library(dplyr)
library(DESeq2)
#library(ffpe) # catplot
```

```{r}
NCORES = 2
registerDoParallel(NCORES)
register(DoparParam())
```

I use the data we generated for the workflow with the most 1000 most variable genes and clusters found using RSEC on W. So, we are working with less clusters than in the published data here. Let's compare DE genes found using edgeR, zingeR-edgeR, and zinbwave-edgeR, DESeq2, zingeR-DESeq2, and zinbwave-DESeq2. DE analysis is performed on all genes.

# Data

We remove cells with no clusters assigned.
```{r datain}
load('../data/fletcher.rda')
load('../data/ceObj_after_RSEC.rda')
colData(core)$workflowCl <- primaryClusterNamed(ceObj)
core = core[, colData(core)$workflowCl != c("-1")]
rm(ceObj)
core
```

We have a list of marker genes where not all markers are in the set of genes we are looking at (we filtered out genes with less than 40 reads in at least 5 cells, it is the criteria used in Fletcher et al.).
```{r}
markers = read.table('../data/oe_markers.txt')
markers = as.vector(markers[,1])
markers = unique(markers)
length(markers)
length(markers[!markers %in% rownames(core)])
length(markers[markers %in% rownames(core)])
markers[markers %in% rownames(core)]
```

# DE genes 

```{r fit}
computeZinbwaveWeights <- function(zinb, counts){
  mu <- getMu(zinb)
  pi <- getPi(zinb)
  theta <- getTheta(zinb)
  theta_mat <- matrix(rep(theta, each = ncol(counts)), ncol = nrow(counts))
  nb_part <- dnbinom(t(counts), size = theta_mat, mu = mu)
  zinb_part <- pi * ( t(counts) == 0 ) + (1 - pi) *  nb_part
  zinbwg <- ( (1 - pi) * nb_part ) / zinb_part 
  t(zinbwg)
}
```

```{r fitedgeRzi}
fit_edgeR_zi <- function(counts, design, contrast, weights, filter = NULL){
  d = DGEList(counts)
  d = suppressWarnings(calcNormFactors(d))
  d$weights <- weights 
  d = estimateDisp(d, design)
  fit = glmFit(d,design)
  
  de = lapply(1:ncol(contrast), function(i){
    glm = glmWeightedF(fit, contrast = contrast[, i], filter = filter)
    tab = glm$table
    tab$contrast = colnames(contrast)[i]
    tab$gene = rownames(tab)
    tab
  })
  de <- do.call(rbind, de)
  de <- data.frame(de, stringsAsFactors = FALSE)
  de = de[, c('gene', 'contrast', 'PValue', 'padjFilter', 'logFC')]
  colnames(de) = c('gene', 'contrast', 'pval', 'padj', 'logfc')
  de
}
```

```{r fitedger}
fit_edgeR <- function(counts, design, contrast, filter = NULL){
  d = DGEList(counts)
  d = suppressWarnings(calcNormFactors(d))
  d = estimateDisp(d, design)
  fit = glmFit(d,design)
  
  de = lapply(1:ncol(contrast), function(i){
    glm = glmLRT(fit, contrast = contrast[, i])
    tab = glm$table
    tab$padj = p.adjust(tab$PValue, "BH")
    tab$contrast = colnames(contrast)[i]
    tab$gene = rownames(tab)
    tab
  })
  de <- do.call(rbind, de)
  de <- data.frame(de, stringsAsFactors = FALSE)
  de = de[, c('gene', 'contrast', 'PValue', 'padj', 'logFC')]
  colnames(de) = c('gene', 'contrast', 'pval', 'padj', 'logfc')
  de
}
```

```{r fitDESeq2zi}
fit_DESeq2_zi <- function(core, design, contrast, weights){
  dds <- DESeqDataSetFromMatrix(assay(core),
                                colData = as.data.frame(colData(core)),
                                design = ~ workflowCl + Batch)
  dds$design <- design
  assays(dds)[["weights"]] <- weights
  dds <- estimateSizeFactors(dds, type = "poscounts")
  dds <- estimateDispersions(dds)
  dds <- nbinomWaldTest(dds, betaPrior = TRUE, useT = TRUE, 
                        df = rowSums(weights) - 2)
  de = lapply(1:ncol(contrast), function(i){
    cc = colnames(contrast)[i]
    cc = strsplit(cc, '-')[[1]]
    tab <- results(dds, contrast = c('workflowCl', cc[1], cc[2]))
    tab$contrast = colnames(contrast)[i]
    tab$gene = rownames(tab)
    tab
  })
  de <- do.call(rbind, de)
  de <- data.frame(de, stringsAsFactors = FALSE)
  de = de[, c('gene', 'contrast', 'pvalue', 'padj', 'log2FoldChange')]
  colnames(de) = c('gene', 'contrast', 'pval', 'padj', 'logfc')
  de
}
```

```{r fitDESeq2}
fit_DESeq2 <- function(core, design, contrast){
  dds <- DESeqDataSetFromMatrix(assay(core),
                                colData = as.data.frame(colData(core)),
                                design = ~ workflowCl + Batch)
  dds$design <- design
  dds <- estimateSizeFactors(dds, type = "poscounts")
  dds <- estimateDispersions(dds)
  dds <- nbinomWaldTest(dds, betaPrior = TRUE)
  de = lapply(1:ncol(contrast), function(i){
    cc = colnames(contrast)[i]
    cc = strsplit(cc, '-')[[1]]
    tab <- results(dds, contrast = c('workflowCl', cc[1], cc[2]))
    tab$contrast = colnames(contrast)[i]
    tab$gene = rownames(tab)
    tab
  })
  de <- do.call(rbind, de)
  de <- data.frame(de, stringsAsFactors = FALSE)
  de = de[, c('gene', 'contrast', 'pvalue', 'padj', 'log2FoldChange')]
  colnames(de) = c('gene', 'contrast', 'pval', 'padj', 'logfc')
  de
}
```


```{r zinbde}
counts = assay(core)
design <- model.matrix(~ 0 + colData(core)$workflowCl + colData(core)$Batch)

contrast = matrix(c(c(1,-1,0,0,0,0,0),
                    c(0,1,0,0,-1,0,0),
                    c(0,1,0,0,0,0,-1),
                    c(1,0,-1,0,0,0,0)
                    ), nrow = 7)
zeromat = matrix(0, ncol = ncol(contrast),
                 nrow = length(unique(colData(core)$Batch)) - 1)
contrast = rbind(contrast, zeromat)
colnames(contrast) = c('c1-c2', 'c2-c5', 'c2-c7', 'c1-c3')
```

```{r zinb}
colData(core)$Batch = factor(colData(core)$Batch)
colData(core)$workflowCl = factor(colData(core)$workflowCl)
```

```{r,eval=FALSE}
print(system.time(zinb <- zinbFit(core, X = '~ 0 + workflowCl + Batch',
                                        epsilon = 1e6)))
save(zinb, file = 'zinb.rda')
```

```{r}
load('zinb.rda')
```

```{r weightszinb}
weights_zinbwave = computeZinbwaveWeights(zinb, counts)
```

```{r weightsedger,eval=FALSE}
weights_zingeR_edgeR <- zeroWeightsLS(counts = counts, design = design,
                                      normalization = "TMM", verbose = FALSE)
save(weights_zingeR_edgeR, file = 'weights_zingeR_edgeR.rda')
```

```{r}
load('weights_zingeR_edgeR.rda')
```

```{r weightsDESeq2,eval=FALSE}
weights_zingeR_DESeq2 <- zeroWeightsLS(counts = counts, design = design,
                                       normalization = "DESeq2_poscounts", 
                                       colData = colData(core),
                                       designFormula = ~ workflowCl + Batch,
                                       verbose = FALSE)
save(weights_zingeR_DESeq2, file = 'weights_zingeR_DESeq2.rda')
```

```{r}
load('weights_zingeR_DESeq2.rda')
```

```{r}
ylim = c(0, 5e5)
par(mfrow = c(1, 3))
hist(weights_zinbwave, main = 'zinbwave', xlab = 'Weights', ylim = ylim)
hist(weights_zingeR_edgeR, main = 'zingeR-edgeR', xlab = 'Weights', ylim = ylim)
hist(weights_zingeR_DESeq2, main = 'zingeR-DESeq2', xlab = 'Weights', ylim = ylim)
par(mfrow = c(1, 1))
```

```{r edgeR}
edgeR <- fit_edgeR(counts, design, contrast)
edgeR$method <- 'edgeR'
```

```{r zingeRedgeR}
zingeR_edgeR <- fit_edgeR_zi(counts, design, contrast,
                             weights = weights_zingeR_edgeR)
zingeR_edgeR$method <- 'zingeR_edgeR'
```

```{r zinbwaveedgeR}
zinbwave_edgeR <- fit_edgeR_zi(counts, design, contrast, 
                            weights = weights_zinbwave,
                            filter = rowMedians(counts))
zinbwave_edgeR$method <- 'zinbwave_edgeR'
```

```{r DESeq2}
design <- model.matrix(~ colData(core)$workflowCl + colData(core)$Batch)
DESeq2 <- fit_DESeq2(core, design, contrast)
DESeq2$method <- 'DESeq2'
```

```{r zingeRDESeq2}
design <- model.matrix(~ colData(core)$workflowCl + colData(core)$Batch)
zingeR_DESeq2 <- fit_DESeq2_zi(core, design, contrast,
                            weights = weights_zingeR_DESeq2)
zingeR_DESeq2$method <- 'zingeR_DESeq2'
```

```{r zinbwaveDESeq2}
design <- model.matrix(~ colData(core)$workflowCl + colData(core)$Batch)
zinbwave_DESeq2 <- fit_DESeq2_zi(core, design, contrast, weights = weights_zinbwave)
zinbwave_DESeq2$method <- 'zinbwave_DESeq2'
```

```{r}
de = rbind(edgeR, zingeR_edgeR, zinbwave_edgeR,
           DESeq2, zingeR_DESeq2, zinbwave_DESeq2)
save(de, file = 'de.rda')
```

# Comparison between methods
## Histogram of pvalues

We are expecting uniformity of the pvalue with a pick close to zero corresponding to DE genes.

```{r hist}
ggplot(de, aes(pval)) + geom_histogram() + facet_grid( ~ method)
```

## Volcano plots
```{r}
for (y in unique(de$contrast)){
  par(mfrow=c(2,3))
  for (x in unique(de$method)){
    temp = de[de$method == x & de$contrast == y, ]
    plot(temp[, 'logfc'], -log10(temp[, 'padj']),
         pch = 20, col = 'gray', cex = .5, xlim = c(-10, 10), ylim = c(0, 50),
         ylab = '-log10(pvalue)', xlab = 'logFC', main = paste(y,'\n',x))
    points(temp[temp$gene %in% markers, 'logfc'], pch=1, col=3, cex=.5, lwd=1,
           -log10(temp[temp$gene %in% markers, 'padj']))
  }
}
par(mfrow=c(1,1))
```

## Concordance between DE genes
### Venn diagram

```{r}
thr = 0.05
```

DE genes are genes with an adjusted pvalue lower than `r thr`.

```{r venn,eval=FALSE}
ve = de %>% group_by(method, gene) %>%
  summarize(smallerpadj = min(padj, na.rm=TRUE)) %>%
  ungroup() %>% as.data.frame()
ve$de = ve$smallerpadj < thr
ve = reshape2::acast(ve[, c(1,2,4)], gene ~ method, sum)

aa <- vennCounts(ve)
vennDiagram(aa, main = 'DE gene, adj pvalue < 0.05')
```

### Concordance plots
```{r,eval=FALSE}
library(ffpe)
trash = lapply(unique(de$contrast), function(x){
  deList = lapply(unique(de$method), function(y){
    temp = de[de$contrast == x & de$method == y , ]
    pval = temp$padj
    names(pval) = temp$gene
    pval
  })
  pp = lapply(c(2:length(deList)), function(i){
    CATplot(deList[[1]], deList[[i]], make.plot = FALSE)
  })
  plot(pp[[1]], col=1, type = "l", ylim = c(0,1), main = paste('Condordance DE genes\n', x))
  if (length(pp)>1) for (i in 2:length(pp)) lines(pp[[i]], col=i, ylim = c(0,1))
  legend("bottomright", fill=1:length(pp),
         legend=unique(de$method)[2:length(deList)])
})
```

## Positive markers

Number of positive markers predicted as DE
```{r}
confusiontab = lapply(unique(de$method), function(x){
  temp = de[de$method == x, ]
  temp = temp %>% group_by(gene) %>% summarize(padj = min(padj))
  padj = temp$padj
  names(padj) = temp$gene
  
  truth = rep(FALSE, length(padj))
  names(truth) = names(padj)
  truth[names(truth) %in% markers] = TRUE
  
  table(truth, padj < thr)
})
names(confusiontab) = unique(de$method)
confusiontab
```

Ranks of positive markers per contrast and method
```{r}
ranks = lapply(unique(de$contrast), function(y){
  lapply(unique(de$method), function(x){
    temp = de[de$method == x & de$contrast == y, ]
    temp$rank = rank(temp$padj)
    temp
  })
})
de = do.call(rbind, do.call(rbind, ranks))
```

```{r}
library(reshape2)
temp = de[de$gene %in% markers,]
ranks = lapply(unique(de$contrast), function(y){
  tt = temp[temp$contrast==y,  c('gene', 'method', 'rank')]
  reshape2::dcast(tt, gene ~ method, mean)
})
names(ranks) = unique(de$contrast)
ranks
```

## Most DE genes per contrast and method
```{r}
ranks = lapply(unique(de$contrast), function(y){
  permethod = lapply(unique(de$method), function(x){
    temp = de[de$method == x & de$contrast == y, ]
    temp = temp[temp$rank < 10, ]
    temp[order(temp$rank), ]
  })
  names(permethod) = unique(de$method)
  permethod
})
names(ranks) = unique(de$contrast)
ranks
```

## Heatmaps 
### FQ

Davide, would you have the transformed data used in the paper? "According to SCONE, the best performing normalization was full-quantile normalization (Bolstad et al., 2003; Bullard et al., 2010), followed by regression-based adjustment for QC measures (see above). Specifically, principal component analysis (PCA) was applied to the matrix of QC measures, and the first PC was used as a quantitative factor of ‘‘unwanted’’ technical variation across cells. Then, the log-transformed quantile-normalized expression measures (adding a pseudocount of 1 prior to the log transformation) for each gene were modeled as a linear function of this technical covariate. The normalized expression measures were defined as the residuals from the linear model fit, rescaled to have the same mean as the log-transformed quantile-normalized read counts."

```{r fqnorm}
fq = EDASeq::betweenLaneNormalization(assay(core), 'full')
fq = log1p(fq)
```

```{r heatmapFQ}
tt = lapply(unique(de$method), function(x){
  temp = de[de$method == x, ]
  deList = lapply(unique(temp$contrast), function(y){
    temp[order(temp[temp$contrast == y, 'padj'])[1:50], 'gene']
  })
  workflowClusters = as.numeric(factor(colData(core)$workflowCl))
  publishedClusters = as.numeric(factor(colData(core)$publishedClusters))
  plotHeatmap(fq[rownames(fq) %in% unique(unlist(deList)), ], main = x,
              sampleData = data.frame(workflow = workflowClusters,
                                      published = publishedClusters))
})
```

### Norm. values
```{r,eval=FALSE}
print(system.time(zinb_k <- zinbwave(core, X = '~Batch', K = 5)))
save(zinb_k, file = 'zinb_k.rda')
```

```{r}
load('zinb_k.rda')
```

```{r heatmapNormValues}
norm = assays(zinb_k)$normalizedValues
tt = lapply(unique(de$method), function(x){
  temp = de[de$method == x, ]
  deList = lapply(unique(temp$contrast), function(y){
    temp[order(temp[temp$contrast == y, 'padj'])[1:50], 'gene']
  })
  workflowClusters = as.numeric(factor(colData(core)$workflowCl))
  publishedClusters = as.numeric(factor(colData(core)$publishedClusters))
  plotHeatmap(norm[rownames(norm) %in% unique(unlist(deList)), ], main = x,
              sampleData = data.frame(workflow = workflowClusters,
                                      published = publishedClusters), breaks=.999)
})
```

## Visualize clustering with DE genes

DE genes are genes with an adjusted pvalue lower than `r thr`. We subset the data to keep only DE genes and visualize the clusters in 2D.

### FQ
```{r pcaDE}
lapply(unique(de$method), function(x){
  temp = unique(de[de$method == x & de$padj < thr, 'gene'])
  pca = prcomp(t(fq[rownames(fq) %in% temp, ]), rank. = 3)
  pairs(pca$x, main = paste('FQ -', x), col = as.numeric(colData(core)$workflowCl), 
       pch = 20)
})
```

### W

```{r}
W = as.data.frame(colData(zinb_k)[,grepl('^W', colnames(colData(zinb_k)))])
mds = cmdscale(dist(W), k = 3)
pairs(mds, col = as.numeric(colData(core)$workflowCl), pch = 20)
```







